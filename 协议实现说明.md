# 蓝牙协议实现详细说明

## 一、协议概述

本应用实现了基于 BLE（低功耗蓝牙）的设备通信协议，符合功能文档中定义的所有要求。

## 二、连接流程

### 1. 蓝牙状态检测（已实现）

```kotlin
// 位置：BleManager.kt
fun isBluetoothEnabled(): Boolean = bluetoothAdapter?.isEnabled == true
```

**实现逻辑**：
- 启动时自动检测蓝牙状态
- 界面实时显示蓝牙状态
- 蓝牙未开启时显示引导提示
- 支持一键跳转到系统蓝牙设置

### 2. 权限处理（已实现）

**Android 12+ 需要的权限**：
- `BLUETOOTH_SCAN` - 扫描设备
- `BLUETOOTH_CONNECT` - 连接设备
- `ACCESS_FINE_LOCATION` - 位置（系统要求）

**Android 11 及以下**：
- `BLUETOOTH` / `BLUETOOTH_ADMIN`
- `ACCESS_FINE_LOCATION`

**实现特点**：
- 运行时动态请求权限
- 权限被拒绝时显示引导
- 支持跳转到应用设置页面

### 3. 设备扫描（已实现）

```kotlin
// 位置：BleManager.kt
fun startScan() {
    bluetoothLeScanner?.startScan(scanCallback)
}
```

**扫描回调处理**：
- 自动去重（同一MAC地址只显示一次）
- 实时更新信号强度（RSSI）
- 支持按设备名称过滤（可扩展）
- 扫描结果通过 StateFlow 推送到UI

### 4. 设备连接（已实现）

```kotlin
fun connect(device: BluetoothDevice) {
    bluetoothGatt = device.connectGatt(context, false, gattCallback)
}
```

**连接状态机**：
```
DISCONNECTED → CONNECTING → CONNECTED → DISCOVERING_SERVICES → READY
```

- `DISCONNECTED`: 未连接
- `CONNECTING`: 正在连接
- `CONNECTED`: 已连接，准备发现服务
- `DISCOVERING_SERVICES`: 正在发现 GATT 服务
- `READY`: 就绪，可以通信

### 5. 服务发现与特征值解析（已实现）

```kotlin
private fun analyzeCharacteristics(gatt: BluetoothGatt) {
    for (service in gatt.services) {
        for (characteristic in service.characteristics) {
            // 自动识别可写特征值
            if (properties and PROPERTY_WRITE != 0) {
                writeCharacteristic = characteristic
            }
            // 自动识别可通知特征值
            if (properties and PROPERTY_NOTIFY != 0) {
                notifyCharacteristic = characteristic
                enableNotification(gatt, characteristic)
            }
        }
    }
}
```

**实现特点**：
- 自动遍历所有服务和特征值
- 智能识别可写和可通知特征值
- 自动启用 Notify 订阅
- 详细的日志输出便于调试

## 三、数据通信

### 1. 数据获取机制（已实现）

**轮询机制**：
```kotlin
private fun startPolling() {
    pollingJob = scope.launch {
        while (isActive && connectionState.value == ConnectionState.READY) {
            writeData(BleProtocol.CMD_GET_DATA)  // 7E 7F 50 FB FD
            delay(300)  // 300ms 间隔
        }
    }
}
```

**特点**：
- 设备就绪后自动开始轮询
- 固定 300ms 间隔（可配置）
- 断开连接时自动停止
- 使用协程实现，不阻塞主线程

### 2. 数据接收与解析（已实现）

**数据缓冲机制**：
```kotlin
private val receivedDataBuffer = mutableListOf<Byte>()

private fun handleReceivedData(data: ByteArray) {
    // 将数据添加到缓冲区
    receivedDataBuffer.addAll(data.toList())
    
    // 查找数据包头 7E 7F 30
    val startIndex = findPacketStart()
    
    // 解析完整数据包
    if (hasCompletePacket()) {
        val sensorData = BleProtocol.parseSensorData(packetData)
        _sensorData.value = sensorData
        receivedDataBuffer.clear()
    }
}
```

**为什么需要缓冲**：
- BLE 数据可能分多个包返回
- 每个包最多 20 字节（或更多，取决于 MTU）
- 传感器数据总共约 59+ 字节
- 需要缓冲并拼接完整数据包

**数据包识别**：
- 数据包头：`7E 7F 30`
- 固定字节顺序（小端序）
- 自动容错处理

### 3. 数据结构解析（已实现）

```kotlin
fun parseSensorData(data: ByteArray): SensorData? {
    // 检查包头
    if (data[0] != 0x7E || data[1] != 0x7F || data[2] != 0x30) {
        return null
    }
    
    // 使用 ByteBuffer 解析
    val buffer = ByteBuffer.wrap(data, 3, data.size - 3)
        .order(ByteOrder.LITTLE_ENDIAN)
    
    return SensorData(
        voltAIn = buffer.float,
        voltAOut = buffer.float,
        // ... 其他字段
        rpm = buffer.int,
        modeNum = buffer.int,
    )
}
```

**字节顺序**：小端序（Little Endian）
- Float: 4 字节，IEEE 754 标准
- Int: 4 字节，有符号整数

**示例数据包**：
```
7E 7F 30  // 包头（3字节）
33 33 33 3F  // voltAIn (float, 0.7)
00 00 00 00  // voltAOut (float, 0.0)
...
DC 05 00 00  // rpm (int, 1500)
01 00 00 00  // modeNum (int, 1)
```

## 四、控制指令

### 1. 模式切换（已实现）

**指令定义**：
```kotlin
enum class WorkMode(val modeNum: Int, val command: ByteArray) {
    E(0, byteArrayOf(0x7E, 0x7F, 0x00, 0xFB, 0xFD)),
    N(1, byteArrayOf(0x7E, 0x7F, 0x01, 0xFB, 0xFD)),
    S(2, byteArrayOf(0x7E, 0x7F, 0x02, 0xFB, 0xFD)),
    S_PLUS(3, byteArrayOf(0x7E, 0x7F, 0x03, 0xFB, 0xFD)),
    R(4, byteArrayOf(0x7E, 0x7F, 0x04, 0xFB, 0xFD)),
}
```

**发送方法**：
```kotlin
fun sendModeCommand(mode: WorkMode): Boolean {
    return writeData(mode.command)
}
```

**UI 交互**：
- 5 个模式按钮（E/N/S/S+/R）
- 当前模式高亮显示
- 设备未就绪时禁用按钮
- 点击即发送指令

### 2. 转速校准（已实现）

**指令生成**：
```kotlin
fun createRpmCalibrationCommand(rpm: Int): ByteArray {
    val rpmClamped = rpm.coerceIn(0, 9999)
    val buffer = ByteBuffer.allocate(4)
        .order(ByteOrder.LITTLE_ENDIAN)
    buffer.putInt(rpmClamped)
    val rpmBytes = buffer.array()
    
    return byteArrayOf(
        0x7E, 0x7F, 0x60,
        rpmBytes[0], rpmBytes[1], rpmBytes[2], rpmBytes[3],
        0xFB, 0xFD
    )
}
```

**示例**：
- 转速 1500 RPM:
  ```
  7E 7F 60 DC 05 00 00 FB FD
  ```
  - `DC 05 00 00` = 1500 (小端序)

- 转速 0 RPM（校准到零点）:
  ```
  7E 7F 60 00 00 00 00 FB FD
  ```

**UI 交互**：
- 数字输入框（仅允许数字）
- 快捷调节按钮（±100、±500 RPM）
- 动态范围限制（根据压力调整）
- 重置按钮（设为当前转速）

### 3. 动态范围限制（已实现）

```kotlin
val bar = pressure / 100f
val dynamicMax = when {
    bar >= 3.30f -> 6000   // 高压时限制低转速
    bar >= 2.80f -> 9000   // 中压
    else -> maxRpm         // 正常压力
}
```

**安全机制**：
- 压力越高，允许的最大转速越低
- 防止高压下发送过高转速
- 实时更新允许范围提示
- 超出范围时禁用发送按钮

## 五、异常处理

### 1. 连接异常（已实现）

```kotlin
override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
    when (newState) {
        BluetoothProfile.STATE_DISCONNECTED -> {
            _connectionState.value = ConnectionState.DISCONNECTED
            _errorMessage.value = "设备已断开连接"
            stopPolling()
        }
    }
}
```

**处理逻辑**：
- 连接失败：显示错误信息
- 连接断开：停止轮询，返回扫描页
- 支持重连机制

### 2. 通信异常（已实现）

```kotlin
private fun handleReceivedData(data: ByteArray) {
    try {
        // 解析数据
    } catch (e: Exception) {
        e.printStackTrace()
        // 缓冲区过大时清空
        if (receivedDataBuffer.size > 200) {
            receivedDataBuffer.clear()
        }
    }
}
```

**保护机制**：
- 数据解析失败时清空缓冲区
- 防止内存泄漏
- 详细的错误日志

### 3. 权限异常（已实现）

```kotlin
fun startScan() {
    if (!hasRequiredPermissions()) {
        _errorMessage.value = "缺少蓝牙权限"
        return
    }
    // ...
}
```

**用户引导**：
- 缺少权限时显示提示卡片
- 提供"授予权限"按钮
- 跳转到权限请求或系统设置

## 六、性能优化

### 1. 协程使用

```kotlin
private val scope = CoroutineScope(Dispatchers.IO)
```

- 所有蓝牙操作在 IO 线程
- 避免阻塞主线程
- 使用 StateFlow 推送状态更新

### 2. 内存管理

```kotlin
fun cleanup() {
    disconnect()
    stopScan()
    pollingJob?.cancel()
}
```

- 及时释放 GATT 连接
- 停止扫描防止电量消耗
- 取消协程任务

### 3. 数据流优化

```kotlin
val sensorData: StateFlow<SensorData?> = _sensorData.asStateFlow()
```

- 使用 StateFlow 替代 LiveData
- 自动处理生命周期
- UI 自动响应数据变化

## 七、调试技巧

### 1. 查看蓝牙日志

```bash
adb logcat -s BleManager
```

**日志包含**：
- `【TX】` 发送的指令
- `【RX】` 接收的数据
- 连接状态变化
- 服务发现结果
- 错误信息

### 2. 数据格式验证

使用在线十六进制转换工具验证：
- Float: https://www.h-schmidt.net/FloatConverter/IEEE754.html
- Int: 计算器切换到程序员模式

### 3. 模拟测试

如需测试数据解析逻辑，可以构造测试数据：

```kotlin
val testData = byteArrayOf(
    0x7E.toByte(), 0x7F, 0x30,  // 包头
    0x33, 0x33, 0x33, 0x3F,      // voltAIn = 0.7
    // ... 其他数据
)
val result = BleProtocol.parseSensorData(testData)
```

## 八、常见问题

### Q1: 设备扫描不到？
**A**: 
1. 确认蓝牙已开启
2. 确认已授予位置权限
3. 确认设备在广播模式
4. 检查设备名称或 UUID 过滤规则

### Q2: 连接成功但无数据？
**A**:
1. 检查特征值是否正确识别
2. 确认 Notify 已启用
3. 查看日志确认是否发送了数据请求指令
4. 确认设备返回的数据格式

### Q3: 数据解析错误？
**A**:
1. 确认字节顺序（小端/大端）
2. 检查数据包头是否正确
3. 确认数据长度是否完整
4. 查看十六进制日志对比协议文档

### Q4: 指令发送失败？
**A**:
1. 确认设备状态为 READY
2. 检查写特征值是否正确
3. 确认设备支持该指令
4. 查看返回的错误码

## 九、扩展开发

### 添加新的传感器字段

1. **修改数据结构**（BleProtocol.kt）：
```kotlin
data class SensorData(
    // ... 现有字段
    val newField: Float,  // 新增字段
)
```

2. **更新解析逻辑**：
```kotlin
fun parseSensorData(data: ByteArray): SensorData? {
    // ...
    return SensorData(
        // ... 现有字段
        newField = buffer.float,
    )
}
```

3. **在 UI 显示**（DeviceControlScreen.kt）：
```kotlin
@Composable
fun NewFieldCard(value: Float) {
    GlassCard {
        Text("新字段: $value")
    }
}
```

### 添加新的控制指令

1. **定义指令**（BleProtocol.kt）：
```kotlin
val CMD_NEW_COMMAND = byteArrayOf(0x7E, 0x7F, 0xXX, 0xFB, 0xFD)
```

2. **添加发送方法**（BleManager.kt）：
```kotlin
fun sendNewCommand(): Boolean {
    return writeData(BleProtocol.CMD_NEW_COMMAND)
}
```

3. **在 UI 调用**：
```kotlin
Button(onClick = { bleManager.sendNewCommand() }) {
    Text("新功能")
}
```

## 十、总结

本应用完整实现了功能文档中的所有要求：

✅ 蓝牙状态检测和权限管理  
✅ BLE 设备扫描和连接  
✅ 自动服务发现和特征值解析  
✅ 300ms 周期性数据轮询  
✅ 传感器数据结构解析  
✅ 工作模式控制（E/N/S/S+/R）  
✅ 转速校准指令  
✅ 异常处理和断连重连  
✅ 现代化 UI 界面  

所有实现都遵循 Android 最佳实践，代码结构清晰，易于维护和扩展。
